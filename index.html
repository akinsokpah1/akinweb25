<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Personal Vault ‚Äî Single File (WebCrypto)</title>
<meta name="description" content="Client-side encrypted personal vault (static HTML). PBKDF2 + AES-GCM (WebCrypto).">
<style>
  :root {
    --bg: #0f1724;
    --card: #071022;
    --accent: #60a5fa;
    --muted: #94a3b8;
    --glass: rgba(255,255,255,0.03);
    color-scheme: dark;
  }
  html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;background:linear-gradient(180deg,#021428 0%, #071025 100%);color:#e6eef8}
  .container{max-width:980px;margin:28px auto;padding:20px}
  header{display:flex;align-items:center;justify-content:space-between}
  h1{margin:0;font-size:20px}
  .card{background:linear-gradient(180deg,var(--glass), rgba(255,255,255,0.01));border-radius:12px;padding:16px;margin-top:16px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
  label{display:block;margin-top:10px;font-size:13px;color:var(--muted)}
  input[type=text], input[type=password], textarea, select{width:100%;padding:10px;margin-top:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  button{background:var(--accent);border:none;padding:10px 14px;border-radius:10px;color:#04233a;font-weight:600;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  .row{display:flex;gap:8px}
  .cols{display:grid;grid-template-columns:1fr 320px;gap:12px}
  .list{max-height:420px;overflow:auto;margin-top:10px}
  .item{padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);margin-bottom:8px}
  .small{font-size:12px;color:var(--muted)}
  footer{margin-top:20px;text-align:center;color:var(--muted);font-size:13px}
  .status{padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);margin-top:8px}
  .test-pass{color:#22c55e}
  .test-fail{color:#ef4444}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .muted-note{font-size:12px;color:var(--muted);margin-top:8px}
  a.link{color:var(--accent);text-decoration:none}
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üîê Personal Vault ‚Äî Single File (WebCrypto)</h1>
      <div class="muted">Static / GitHub Pages ready ‚Äî Encryption is local to your browser.</div>
    </header>

    <div class="card" id="authCard">
      <div class="muted">Passphrase unlocks your vault. <strong>DO NOT FORGET</strong> ‚Äî we store only ciphertext locally.</div>
      <label>Passphrase</label>
      <input id="passphrase" type="password" placeholder="Choose a strong passphrase..." autocomplete="new-password">
      <div class="row" style="margin-top:10px">
        <button id="unlockBtn">Unlock / Create Vault</button>
        <button id="exportBtn">Export Encrypted Vault</button>
        <button id="importBtn">Import Vault</button>
      </div>
      <div class="muted-note">This build uses PBKDF2 (SHA-256) and AES-GCM (256-bit). If you want Argon2/XChaCha20 later, I can provide an upgraded single-file variant.</div>
    </div>

    <div class="cols">
      <div>
        <div class="card">
          <h3>Upload file</h3>
          <div class="muted">Files are encrypted in the browser using your passphrase-derived key.</div>
          <label>Select file</label>
          <input id="fileInput" type="file">
          <label>Type / tags (comma separated)</label>
          <input id="fileTags" type="text" placeholder="e.g. id, passport, photo">
          <div style="margin-top:8px"><button id="uploadFileBtn">Encrypt & Store</button></div>
        </div>

        <div class="card">
          <h3>Add timeline event</h3>
          <label>Title</label>
          <input id="eventTitle" type="text" placeholder="Graduation, Wedding...">
          <label>Date & Time</label>
          <input id="eventDate" type="datetime-local">
          <label>Description</label>
          <textarea id="eventDesc" rows="4"></textarea>
          <label>Tags</label>
          <input id="eventTags" type="text" placeholder="memories, 2010">
          <div style="margin-top:8px" class="row"><button id="addEventBtn">Add Event</button><button id="clearBtn">Clear Vault</button></div>
        </div>

        <div class="card">
          <h3>Test harness</h3>
          <div class="muted">Run automated crypto tests to ensure this browser supports the required primitives (PBKDF2 + AES-GCM).</div>
          <div style="margin-top:8px" class="row"><button id="runTestsBtn">Run Tests</button></div>
          <div id="testResults" class="status"></div>
        </div>
      </div>

      <aside>
        <div class="card">
          <h3>Vault Browser</h3>
          <div class="muted">Unlock to view items and download decrypted copies.</div>
          <label>Search</label>
          <input id="search" type="text" placeholder="search titles, tags...">
          <div class="list" id="list"></div>
        </div>

        <div class="card">
          <h3>Export / Backup</h3>
          <div class="muted">Export contains only ciphertext + salts + IVs and manifest. Keep your passphrase safe.</div>
          <div style="margin-top:8px" class="controls">
            <button id="downloadAllBtn">Download Encrypted Archive (.json)</button>
            <button id="verifyBtn">Verify Backups (SHA-256)</button>
          </div>
        </div>
      </aside>
    </div>

    <footer>Made for private use. This is a static-only vault ‚Äî no server, no external uploads. If you forget your passphrase your data cannot be recovered.</footer>
  </div>

<script>
/*
  Single-file static vault using WebCrypto.
  - Key derivation: PBKDF2(SHA-256) with per-vault salt and configurable iterations.
  - AEAD: AES-GCM (256-bit).
  - Storage: IndexedDB for items (ciphertext + metadata).
  - Export: JSON manifest with ciphertexts and metadata (no plaintext).
  - Test harness included.
*/

/* ----------------- Crypto parameters ----------------- */
/* You can increase PBKDF2 iterations for stronger brute-force resistance, but
   larger iteration counts slow down deriveKey on low-end devices. For long-term
   safety consider re-encrypting (migrate) every few years with higher params. */
const PBKDF2_ITERATIONS = 250000; // conservative, adjust for your device
const PBKDF2_HASH = 'SHA-256';
const KEY_BYTES = 32; // 256-bit AES key
const AES_ALG = 'AES-GCM';
const AES_IV_BYTES = 12; // 96-bit recommended for AES-GCM

/* ----------------- IndexedDB ----------------- */
const DB_NAME = 'personal_vault_db_static';
const DB_STORE = 'items';

function openDB(){
  return new Promise((res, rej) => {
    const r = indexedDB.open(DB_NAME, 1);
    r.onupgradeneeded = e => {
      const db = e.target.result;
      if(!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE, { keyPath: 'id' });
    };
    r.onsuccess = e => res(e.target.result);
    r.onerror = e => rej(e.target.error);
  });
}
async function putItem(item){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(DB_STORE,'readwrite'); tx.objectStore(DB_STORE).put(item); tx.oncomplete = ()=>res(); tx.onerror = e=>rej(e); }); }
async function getAllItems(){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(DB_STORE,'readonly'); const req = tx.objectStore(DB_STORE).getAll(); req.onsuccess = ()=>res(req.result); req.onerror = e=>rej(e); }); }
async function clearAll(){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(DB_STORE,'readwrite'); tx.objectStore(DB_STORE).clear(); tx.oncomplete = ()=>res(); tx.onerror = e=>rej(e); }); }

/* ----------------- helpers ----------------- */
function randBytes(n){
  const b = new Uint8Array(n);
  crypto.getRandomValues(b);
  return b;
}
function bufToB64(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
function b64ToBuf(b64){ const s = atob(b64); const arr = new Uint8Array(s.length); for(let i=0;i<s.length;i++) arr[i]=s.charCodeAt(i); return arr; }
function nowISO(){ return new Date().toISOString(); }
function uid(){ return 'id_' + Math.random().toString(36).slice(2,10) + Date.now().toString(36); }

/* SHA-256 using Subtle */
async function sha256(buf){
  const h = await crypto.subtle.digest('SHA-256', buf);
  return new Uint8Array(h);
}

/* PBKDF2 derive: returns CryptoKey and raw key bytes */
async function deriveKeyFromPassphrase(passphrase, salt, iterations = PBKDF2_ITERATIONS){
  const enc = new TextEncoder().encode(passphrase);
  const baseKey = await crypto.subtle.importKey('raw', enc, { name: 'PBKDF2' }, false, ['deriveBits','deriveKey']);
  // derive raw bytes
  const derivedBits = await crypto.subtle.deriveBits(
    { name: 'PBKDF2', salt: salt, iterations: iterations, hash: PBKDF2_HASH },
    baseKey,
    KEY_BYTES * 8
  );
  const raw = new Uint8Array(derivedBits);
  const key = await crypto.subtle.importKey('raw', raw, { name: AES_ALG, length: 256 }, false, ['encrypt','decrypt']);
  return { key, raw }; // raw Uint8Array & CryptoKey
}

/* AES-GCM encrypt/decrypt helpers */
async function aesGcmEncrypt(plainBuf, cryptoKey){
  const iv = randBytes(AES_IV_BYTES);
  const ct = await crypto.subtle.encrypt({ name: AES_ALG, iv: iv }, cryptoKey, plainBuf);
  return { iv: new Uint8Array(iv), ciphertext: new Uint8Array(ct) };
}
async function aesGcmDecrypt(ciphertextBuf, iv, cryptoKey){
  const pt = await crypto.subtle.decrypt({ name: AES_ALG, iv: iv }, cryptoKey, ciphertextBuf);
  return new Uint8Array(pt);
}

/* ----------------- Session state ----------------- */
let sessionKey = null;           // CryptoKey for AES operations (in-memory while unlocked)
let sessionRawKey = null;        // raw Uint8Array (used for backup verification); zero this out on logout if wanted
let sessionMeta = null;          // { salt_b64, iterations, created_at }

/* ----------------- UI wiring ----------------- */
document.getElementById('unlockBtn').addEventListener('click', async ()=>{
  const pass = document.getElementById('passphrase').value;
  if(!pass) { alert('Enter a passphrase'); return; }
  // read or create salt in localStorage
  let saltB64 = localStorage.getItem('vault_salt_static_v1');
  if(!saltB64){
    const salt = randBytes(16);
    saltB64 = bufToB64(salt);
    localStorage.setItem('vault_salt_static_v1', saltB64);
  }
  const salt = b64ToBuf(saltB64);
  try {
    const { key, raw } = await deriveKeyFromPassphrase(pass, salt, PBKDF2_ITERATIONS);
    sessionKey = key;
    sessionRawKey = raw;
    sessionMeta = { kdf: 'pbkdf2', hash: PBKDF2_HASH, iterations: PBKDF2_ITERATIONS, salt: saltB64, created_at: nowISO() };
    await refreshList();
    alert('Vault unlocked for this session (key in memory).');
  } catch(err){
    console.error(err); alert('Key derivation failed: ' + err.message);
  }
});

/* Upload & encrypt file */
document.getElementById('uploadFileBtn').addEventListener('click', async ()=>{
  if(!sessionKey){ alert('Unlock first'); return; }
  const f = document.getElementById('fileInput').files[0];
  if(!f){ alert('Choose a file'); return; }
  const tags = document.getElementById('fileTags').value.split(',').map(s=>s.trim()).filter(Boolean);
  const buf = new Uint8Array(await f.arrayBuffer());
  // encrypt
  const { iv, ciphertext } = await aesGcmEncrypt(buf, sessionKey);
  const item = {
    id: uid(),
    type: 'file',
    filename: f.name,
    mimetype: f.type || 'application/octet-stream',
    created_at: nowISO(),
    tags,
    cipher_b64: bufToB64(ciphertext),
    iv_b64: bufToB64(iv),
    kdf_meta: sessionMeta,
    hash_b64: bufToB64(await sha256(buf)),
    format_version: 1
  };
  await putItem(item);
  await refreshList();
  alert('Encrypted file stored in IndexedDB (client-only).');
});

/* Add timeline event */
document.getElementById('addEventBtn').addEventListener('click', async ()=>{
  if(!sessionKey){ alert('Unlock first'); return; }
  const title = document.getElementById('eventTitle').value.trim();
  if(!title) { alert('Enter a title'); return; }
  const date = document.getElementById('eventDate').value || new Date().toISOString();
  const desc = document.getElementById('eventDesc').value || '';
  const tags = document.getElementById('eventTags').value.split(',').map(s=>s.trim()).filter(Boolean);
  const payload = new TextEncoder().encode(JSON.stringify({ title, date, desc, tags }));
  const { iv, ciphertext } = await aesGcmEncrypt(payload, sessionKey);
  const item = {
    id: uid(),
    type: 'event',
    created_at: nowISO(),
    tags,
    cipher_b64: bufToB64(ciphertext),
    iv_b64: bufToB64(iv),
    kdf_meta: sessionMeta,
    format_version: 1
  };
  await putItem(item);
  await refreshList();
  alert('Event added.');
});

/* Clear vault (local only) */
document.getElementById('clearBtn').addEventListener('click', async ()=>{
  if(!confirm('This deletes ALL local items in this browser. Are you sure?')) return;
  await clearAll();
  await refreshList();
});

/* Refresh UI list */
async function refreshList(){
  const list = document.getElementById('list');
  list.innerHTML = '';
  const items = await getAllItems();
  // optionally filter by search
  const q = document.getElementById('search').value.trim().toLowerCase();
  const filtered = items.filter(it => {
    if(!q) return true;
    const s = (it.filename||'') + ' ' + (it.tags||[]).join(' ') + ' ' + (it.type||'');
    return s.toLowerCase().includes(q);
  });
  filtered.sort((a,b)=> (a.created_at < b.created_at) ? 1 : -1);
  for(const it of filtered){
    const el = document.createElement('div'); el.className='item';
    el.innerHTML = `<div><strong>${it.type}</strong> <span class="small">${it.filename || ''}</span></div>
                    <div class="small">${it.created_at}</div>`;
    const btns = document.createElement('div'); btns.className='row';
    const view = document.createElement('button'); view.textContent='Decrypt'; view.onclick = async ()=>{ await handleDecryptItem(it); };
    const dl = document.createElement('button'); dl.textContent='Download'; dl.onclick = async ()=>{ await handleDownloadItem(it); };
    btns.appendChild(view); btns.appendChild(dl);
    el.appendChild(btns);
    list.appendChild(el);
  }
}

/* Decrypt / show item (events show JSON, files are kept for download) */
async function handleDecryptItem(it){
  if(!sessionKey){ alert('Unlock first'); return; }
  try {
    const cipher = b64ToBuf(it.cipher_b64);
    const iv = b64ToBuf(it.iv_b64);
    const plain = await aesGcmDecrypt(cipher.buffer, iv, sessionKey);
    if(it.type === 'event'){
      const obj = JSON.parse(new TextDecoder().decode(plain));
      alert(JSON.stringify(obj, null, 2));
    } else {
      alert('File decrypted in memory ‚Äî use Download to save to disk.');
    }
  } catch(e){
    alert('Decryption failed ‚Äî wrong passphrase or corrupted data.');
  }
}

/* Download decrypted item */
async function handleDownloadItem(it){
  if(!sessionKey){ alert('Unlock first'); return; }
  try {
    const cipher = b64ToBuf(it.cipher_b64);
    const iv = b64ToBuf(it.iv_b64);
    const plain = await aesGcmDecrypt(cipher.buffer, iv, sessionKey);
    if(it.type === 'file'){
      const blob = new Blob([plain], { type: it.mimetype });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = it.filename || 'download.bin'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    } else {
      const txt = new TextDecoder().decode(plain);
      const blob = new Blob([txt], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = (it.title || 'event') + '.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
  } catch(e){
    alert('Download/decrypt failed: ' + e.message);
  }
}

/* Export manifest (ciphertexts + metadata) */
document.getElementById('downloadAllBtn').addEventListener('click', async ()=>{
  const items = await getAllItems();
  const manifest = { exported_at: nowISO(), format_version:1, items };
  const raw = new TextEncoder().encode(JSON.stringify(manifest));
  const h = await sha256(raw);
  manifest.manifest_hash = bufToB64(h);
  const blob = new Blob([JSON.stringify(manifest, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'vault-export-' + new Date().toISOString().slice(0,10) + '.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

/* Verify backups (attempt decrypt each file and compare hash) */
document.getElementById('verifyBtn').addEventListener('click', async ()=>{
  if(!sessionKey){ alert('Unlock first'); return; }
  const items = await getAllItems();
  const problems = [];
  for(const it of items){
    if(it.type === 'file'){
      try {
        const cipher = b64ToBuf(it.cipher_b64);
        const iv = b64ToBuf(it.iv_b64);
        const plain = await aesGcmDecrypt(cipher.buffer, iv, sessionKey);
        const h = await sha256(plain);
        if(bufToB64(h) !== it.hash_b64) problems.push({ id: it.id, reason: 'hash mismatch' });
      } catch(e){
        problems.push({ id: it.id, reason: 'cannot decrypt with current session key' });
      }
    }
  }
  if(problems.length === 0) alert('All items verified OK'); else alert('Problems found: ' + JSON.stringify(problems));
});

/* Import manifest (ciphertexts only) */
document.getElementById('importBtn').addEventListener('click', async ()=>{
  const f = document.createElement('input'); f.type='file'; f.accept='.json'; f.onchange = async ()=>{
    const file = f.files[0]; if(!file) return;
    const obj = JSON.parse(await file.text());
    if(!obj.items) { alert('Invalid manifest'); return; }
    for(const it of obj.items) await putItem(it);
    await refreshList();
    alert('Imported ' + obj.items.length + ' items (ciphertexts only).');
  }; f.click();
});

/* Migration helper (re-encrypt everything with new PBKDF2 params) */
async function migrateToNewParams(newIterations){
  if(!sessionKey) throw new Error('unlock first');
  const pass = document.getElementById('passphrase').value; if(!pass) throw new Error('passphrase missing');
  const items = await getAllItems();
  const newSalt = randBytes(16);
  const { key: newCryptoKey, raw: newRaw } = await deriveKeyFromPassphrase(pass, newSalt, newIterations);
  for(const it of items){
    try {
      const cipher = b64ToBuf(it.cipher_b64);
      const iv = b64ToBuf(it.iv_b64);
      const plain = await aesGcmDecrypt(cipher.buffer, iv, sessionKey);
      const { iv: newIv, ciphertext: newCipher } = await aesGcmEncrypt(plain, newCryptoKey);
      it.cipher_b64 = bufToB64(newCipher);
      it.iv_b64 = bufToB64(newIv);
      it.kdf_meta = { kdf: 'pbkdf2', hash: PBKDF2_HASH, iterations: newIterations, salt: bufToB64(newSalt) };
      await putItem(it);
    } catch(e){
      console.error('skip item', it.id, e);
    }
  }
  // update session to new key
  sessionKey = newCryptoKey; sessionRawKey = newRaw;
  localStorage.setItem('vault_salt_static_v1', bufToB64(newSalt));
  alert('Migration finished (best-effort).');
}
window.vault = { migrateToNewParams };

/* ----------------- Test harness ----------------- */
document.getElementById('runTestsBtn').addEventListener('click', async ()=>{
  const out = document.getElementById('testResults');
  out.innerHTML = '';
  try {
    // PBKDF2 derive test
    const pass = 'test-pass';
    const salt = randBytes(16);
    const { key: k1, raw: raw1 } = await deriveKeyFromPassphrase(pass, salt, PBKDF2_ITERATIONS);
    if(!k1) { out.innerHTML = '<div class="test-fail">KDF derive: FAIL</div>'; return; }
    out.innerHTML += '<div class="test-pass">KDF derive (PBKDF2): OK</div>';

    // AES-GCM encrypt/decrypt test
    const data = new TextEncoder().encode('hello world test');
    const { iv, ciphertext } = await aesGcmEncrypt(data, k1);
    const dec = await aesGcmDecrypt(ciphertext.buffer, iv, k1);
    const ok = new TextDecoder().decode(dec) === 'hello world test';
    out.innerHTML += ok ? '<div class="test-pass">AES-GCM encrypt/decrypt: PASS</div>' : '<div class="test-fail">AES-GCM encrypt/decrypt: FAIL</div>';

    // SHA-256 test
    const h = await sha256(new TextEncoder().encode('x'));
    out.innerHTML += (h && h.length === 32) ? '<div class="test-pass">SHA-256: OK</div>' : '<div class="test-fail">SHA-256: FAIL</div>';
  } catch(e){
    out.innerHTML = '<div class="test-fail">Test error: ' + (e.message || e) + '</div>';
  }
});

/* init */
refreshList();
</script>
</body>
</html>
